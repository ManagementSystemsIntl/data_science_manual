[
  {
    "objectID": "How R works.html#basic-use",
    "href": "How R works.html#basic-use",
    "title": "How R works",
    "section": "Basic use",
    "text": "Basic use\nIn R, you create objects and then use those objects for your analysis. Objects are made up of whatever you assign them to. They can be a direct value, a file, a graphic, etc. Here’s an example:\n\na &lt;- 5\n\nWe have assigned the object, a, the value of 5. The assignment operator &lt;- is what tells R to assign the value of 5 to a.\nNow we can use the object a. As in a + a. We use the # to annotate our code for human readers. R will not compute any text to the right of a #. Annotating code is very helpful for code review and for remembering what you were doing when you open up a script that you have not worked on for 6 months.\n\n# Assign a the value of 5\na &lt;- 5\n\n# Add a + a (or 5 +5)\na+a\n\n[1] 10\n\n\nNotice that R understands to output the value of a+a without any additional instructions. Or, you could store the value of a + a as a new object.\n\na &lt;- 5\n\n# Assign the value of a + a to b\nb &lt;- a + a\n\n#print value of b\nb\n\n[1] 10"
  },
  {
    "objectID": "How R works.html#data-structures",
    "href": "How R works.html#data-structures",
    "title": "How R works",
    "section": "Data Structures",
    "text": "Data Structures\nThe primary data structures in R are vectors, matrices, lists, and data frames. They all basically begin as a vector. The idea here is not to master what the data structures are, but to understand how R handles each one as it will affect more advanced coding operations. Knowledge of data structures is also helpful when debugging code because error messages will reference the different data structures.\nNaturally, we will start with the most “atomic” of the data structures, the (atomic) vector.\n\nVectors\nA vector is the most basic data structure in R. A vector can only contain a single data type. It can be any of logical, integer, double, character, complex or raw, but it cannot mix and match types.\nHere’s a vector\n\n# Create vectors\nvector &lt;- 10\nvector1 &lt;- c(10, 14, 27, 99)\nvector2 &lt;- c(\"purple\", \"blue\", \"red\")\n\n# Print the value of each vector \nvector\n\n[1] 10\n\nvector1\n\n[1] 10 14 27 99\n\nvector2\n\n[1] \"purple\" \"blue\"   \"red\""
  },
  {
    "objectID": "How R works.html#matrices",
    "href": "How R works.html#matrices",
    "title": "How R works",
    "section": "Matrices",
    "text": "Matrices\nA matrix is a vector with dimensions - it has rows and columns. As with a vector, the elements of a matrix must be of the same data type. Here are a few examples.\n\n# Create a 2 x 2 matrix with the numbers 1 through 4\nm &lt;- matrix(1:4, nrow = 2, ncol = 2) \n\n# Note that the matrix is filled column-wise. (e.g., it completes # the left column with 1 and 2 before moving to the right column \n# and entering 3 and 4 \nm\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4"
  },
  {
    "objectID": "How R works.html#lists",
    "href": "How R works.html#lists",
    "title": "How R works",
    "section": "Lists",
    "text": "Lists\nA list is a vector that can have multiple data types. You can call class() on any object in R to display the type of object that it is.\n\n# Make a list a\na &lt;- list(10, \"red\", 74, \"blue\")\n\n# What is the class, or type, of a?\nclass(a)\n\n[1] \"list\""
  },
  {
    "objectID": "How R works.html#dataframes",
    "href": "How R works.html#dataframes",
    "title": "How R works",
    "section": "Dataframes",
    "text": "Dataframes\nYou can think of a dataframe as your Excel Spreadheet. At MSI, this is the most common form of dataset. We read a .xlsx or .csv file into R, and we get a dataframe. At its core, a dataframe is a list of lists where each list (column) is the same length (i.e., it is a “rectangular list”). A data frame can contain many types of data because it is a collection of lists, and lists, as you remember, can consist of multiple data types.\n\n# Create a dataframe called df\n\ndf &lt;- data.frame(a = c(10,20,30,40)\n                 , b = c('book', 'pen', 'textbook', 'pencil_case')\n                 , c = c(TRUE,FALSE,TRUE,FALSE)\n                 , d = c(TRUE,FALSE,TRUE,FALSE))\n\n# Print df\ndf\n\n\n\n\na\nb\nc\nd\n\n\n10\nbook\nTRUE\nTRUE\n\n\n20\npen\nFALSE\nFALSE\n\n\n30\ntextbook\nTRUE\nTRUE\n\n\n40\npencil_case\nFALSE\nFALSE\n\n\n\n\n\n\n\nNow that we have a dataframe, we want to look at some of its details using glimpse().\n\n# Create a dataframe called df\n\ndf &lt;- data.frame(a = c(10,20,30,40)\n                 , b = c('book', 'pen', 'textbook', 'pencil_case')\n                 , c = c(TRUE,FALSE,TRUE,FALSE)\n                 , d = c(TRUE,FALSE,TRUE,FALSE))\n\n# Look at structure of df\ndplyr::glimpse(df)\n\nRows: 4\nColumns: 4\n$ a &lt;dbl&gt; 10, 20, 30, 40\n$ b &lt;chr&gt; \"book\", \"pen\", \"textbook\", \"pencil_case\"\n$ c &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE\n$ d &lt;lgl&gt; TRUE, FALSE, TRUE, FALSE"
  },
  {
    "objectID": "How R works.html#factors",
    "href": "How R works.html#factors",
    "title": "How R works",
    "section": "Factors",
    "text": "Factors\nFactors are numeric vectors that contain only pre-defined values (categories), and where each of these categories has a label.\n\na &lt;- sample(1:2, 100, replace=T)\ntable(a)\n\na\n 1  2 \n49 51 \n\n\n\na_f &lt;- factor(a, labels=c(\"Male\",\"Female\"))\ntable(a_f)\n\na_f\n  Male Female \n    49     51 \n\n\nNote that the labels are just labels, the underlying representation is still 1 and 2.\n\nstr(a_f)\n\n Factor w/ 2 levels \"Male\",\"Female\": 1 1 1 2 2 1 1 2 1 2 ...\n\n\nFactors can sometimes cause trouble. More contemporary practice is to stick with an integer data type and add your own labels.\n\nlibrary(tidyverse)\nlibrary(sjmisc)\nlibrary(sjlabelled)\n\na_l &lt;- a %&gt;%\n  set_labels(labels=c(\"Male\",\"Female\"))\nstr(a_l)\n\n int [1:100] 1 1 1 2 2 1 1 2 1 2 ...\n - attr(*, \"labels\")= Named num [1:2] 1 2\n  ..- attr(*, \"names\")= chr [1:2] \"Male\" \"Female\"\n\n\n\nfrq(a)\n\nx &lt;integer&gt; \n# total N=100 valid N=100 mean=1.51 sd=0.50\n\nValue |  N | Raw % | Valid % | Cum. %\n-------------------------------------\n    1 | 49 |    49 |      49 |     49\n    2 | 51 |    51 |      51 |    100\n &lt;NA&gt; |  0 |     0 |    &lt;NA&gt; |   &lt;NA&gt;\n\n\n\nfrq(a_f)\n\nx &lt;categorical&gt; \n# total N=100 valid N=100 mean=1.51 sd=0.50\n\nValue  |  N | Raw % | Valid % | Cum. %\n--------------------------------------\nMale   | 49 |    49 |      49 |     49\nFemale | 51 |    51 |      51 |    100\n&lt;NA&gt;   |  0 |     0 |    &lt;NA&gt; |   &lt;NA&gt;\n\n\n\nfrq(a_l)\n\nx &lt;integer&gt; \n# total N=100 valid N=100 mean=1.51 sd=0.50\n\nValue |  Label |  N | Raw % | Valid % | Cum. %\n----------------------------------------------\n    1 |   Male | 49 |    49 |      49 |     49\n    2 | Female | 51 |    51 |      51 |    100\n &lt;NA&gt; |   &lt;NA&gt; |  0 |     0 |    &lt;NA&gt; |   &lt;NA&gt;\n\n\nThe underlying integers behind factor labels have no ordering. To establish an ordering, make an ordered factor.\n\nord &lt;- sample(1:5, 100, replace=T)\ntable(ord)\n\nord\n 1  2  3  4  5 \n23 18 20 21 18 \n\n\n\nord.labs &lt;- c(\"Not at all\",\"A little\",\"Somewhat\",\"Much\",\"Completely\")\nord.fac &lt;- ordered(ord, labels=ord.labs)\ntable(ord.fac)\n\nord.fac\nNot at all   A little   Somewhat       Much Completely \n        23         18         20         21         18 \n\n\nBut again, you have to be careful not to accidentally jumble the underlying integers with the ordered labels.\nTo keep things more explicit, I would still stick with an integer variable with labels, rather than an ordered factor.\n\nord.l &lt;- ord %&gt;%\n  set_labels(labels=ord.labs)\ntable(ord.l)\n\nord.l\n 1  2  3  4  5 \n23 18 20 21 18 \n\n\n\nfrq(ord.l)\n\nx &lt;integer&gt; \n# total N=100 valid N=100 mean=2.93 sd=1.43\n\nValue |      Label |  N | Raw % | Valid % | Cum. %\n--------------------------------------------------\n    1 | Not at all | 23 |    23 |      23 |     23\n    2 |   A little | 18 |    18 |      18 |     41\n    3 |   Somewhat | 20 |    20 |      20 |     61\n    4 |       Much | 21 |    21 |      21 |     82\n    5 | Completely | 18 |    18 |      18 |    100\n &lt;NA&gt; |       &lt;NA&gt; |  0 |     0 |    &lt;NA&gt; |   &lt;NA&gt;\n\n\nWhen you’re ready to dive into this sometimes-frustrating subject, start here:\n\nforcats package in the tidyverse\nworking with labelled data\nwrangling categorical data in R"
  },
  {
    "objectID": "How R works.html#sub-setting",
    "href": "How R works.html#sub-setting",
    "title": "How R works",
    "section": "Sub-setting",
    "text": "Sub-setting\nYou can cut up your objects into other objects. The base R way to do this is to use brackets.\n\nsub-setting vectors\n\na &lt;- rpois(5, 8)\na\n\n[1]  5 12  7 11  9\n\n\n\na[1:3]\n\n[1]  5 12  7\n\n\n\na[c(1,4,2)]\n\n[1]  5 11 12\n\n\n\na[-2]\n\n[1]  5  7 11  9\n\n\n\na[a&gt;9]\n\n[1] 12 11\n\n\n\n\nsub-setting data frames\nSince data frames are two dimensional, you usually (but not always) need to specify both dimensions.\n\nstr(df)\n\n'data.frame':   4 obs. of  4 variables:\n $ a: num  10 20 30 40\n $ b: chr  \"book\" \"pen\" \"textbook\" \"pencil_case\"\n $ c: logi  TRUE FALSE TRUE FALSE\n $ d: logi  TRUE FALSE TRUE FALSE\n\n\n\ndf_f &lt;- df[1:5,2]\nstr(df_f)\n\n chr [1:5] \"book\" \"pen\" \"textbook\" \"pencil_case\" NA\n\n\nThe comma within the bracket specifies rows and columns.\nMore contemporary practice uses what is referred to as the tidyverse."
  },
  {
    "objectID": "Data cleaning and preparation.html#instrument-design-and-scripting",
    "href": "Data cleaning and preparation.html#instrument-design-and-scripting",
    "title": "Data cleaning and preparation",
    "section": "Instrument Design and Scripting",
    "text": "Instrument Design and Scripting\n\nInstrument Design and Scripting Workflows\nIn the process of designing and scripting instruments for data collection, it is crucial to follow a systematic workflow that ensures accuracy, completeness, and ease of updating. Before going through this section it is important to consider several overarching points:\n\nClient preferences will likely dictate in what form instruments are shared.\nSpending the time to develop a thorough data dictionary from the onset is worth it!\nInvolve both HO and FO activity managers in instrument pre-testing whenever possible.\n\nBelow, we outline two workflows: the “Typical” Instrument Design and Scripting Workflow, and the “Proposed” Instrument Design and Scripting Workflow. The proposed workflow aims to address and improve upon the shortcomings observed in the typical workflow.\n“Typical” Instrument Design and Scripting Workflow The typical workflow consists of five main stages:\nIP/Client Document Review and Consultations:\n\nThis initial stage involves reviewing relevant documents provided by the implementing partners (IPs) or clients and conducting consultations to understand the requirements and context.\n\nInstrument Development in Word:\n\nBased on the gathered information, instruments are developed in Word documents. This step is critical but often leads to instruments that are difficult to update and manage, especially regarding data names and skip logic.\n\nClient/IP Feedback:\n\nThe draft instruments are then shared with the client or IP for feedback. This stage is essential for ensuring the instrument meets the client’s needs and expectations.\n\nUpdate Instruments in Word:\n\nFollowing feedback, the instruments are updated in Word. This iterative process can be time-consuming and prone to errors, particularly in managing complex logic and data structures. Script Instruments from Word into Data Collection Software:\nFinally, the instruments are scripted into the data collection software. This step often reveals issues not apparent in the Word documents, such as missing data names and ineffective skip logic, making the scripting process cumbersome. Typically, the client version of the instruments lacks unique data names, effective skip logic, and is challenging to update, leading to inefficiencies and potential errors in the data collection process.\n\nProposed Instrument Design and Scripting Workflow To overcome the limitations of the typical workflow, the proposed workflow introduces a more structured and efficient approach.\nIP/Client Document Review and Consultations:\n\nAs in the typical workflow, this stage involves a thorough review of documents and consultations to gather requirements.\n\nData Dictionary Development:\n\nInstead of directly developing instruments in Word, this stage focuses on creating a comprehensive data dictionary. The data dictionary includes unique data names, skip logic, and translations, providing a clear and structured framework for the instruments.\n\nClient/IP Feedback:\n\nThe data dictionary is shared with the client or IP for feedback, ensuring that all necessary elements are captured and agreed upon before developing the instruments. Update Data Dictionary:\n\nBased on the feedback, the data dictionary is updated. This step ensures that any changes or additions are systematically incorporated, maintaining the integrity and structure of the data. Script Instruments into Data Collection Software:\n\nWith a well-defined data dictionary, scripting the instruments into the data collection software becomes more straightforward and less error-prone. The unique data names and effective skip logic defined in the data dictionary ensure a smooth transition from design to implementation.\n\nBy adopting the proposed workflow, the instrument design and scripting process becomes more efficient and reliable. The use of a data dictionary ensures that all elements are clearly defined and managed, reducing the likelihood of errors and making the instruments easier to update and maintain. This approach not only improves the quality of the instruments but also enhances the overall efficiency of the data collection process."
  },
  {
    "objectID": "Data cleaning and preparation.html#common-scripting-issues",
    "href": "Data cleaning and preparation.html#common-scripting-issues",
    "title": "Data cleaning and preparation",
    "section": "Common Scripting Issues",
    "text": "Common Scripting Issues"
  }
]